% thesisintroduction.tex
% Introductory chapter of document.

\chapter{Introduction}
\label{cha:introduction}

Virtual platforms are becoming a critical tool in the software industry in order to provide cost-effective \dvttermttm\ gains and meet the ever-shortening product life-cycles\dvtcmdcitebib[p.~50,~52]{journals:magnusson:2002}\dvtcmdcitebib[p.~268]{journals:yi:2006} (see \dvtcmdcitebib{magazines:magnusson:2004} for an overview of the benefits of full-system simulation).
Virtual platforms may deliver these \dvttermttm -benefits in two major ways.
Firstly, virtual platforms enable pre-silicon development, that is; software development can begin prior to next-generation hardware being available\dvtcmdcitebib[p.~52]{journals:magnusson:2002}.
Secondly, virtual platforms may provide additional development tools compared to working with actual hardware.
For example, some virtual platforms allow simulated systems to be stopped synchronously without affecting \dvttermtiming\ or states of the \dvttermtarget\ software\dvtcmdcitebib[p.~61]{inproceedings:yu:2012}, and allow investigation into race conditions and other parallel programming issues\dvtcmdcitebib[p.~1]{inproceedings:schumacher:2010}\dvtcmdcitebib[p.~7]{publications:leupers:2010}.
Additionally, such platforms may allow intricate inspection of simulated hardware, such as memory, caches, and registers\dvtcmdcitebib[p.~54]{journals:magnusson:2002}.
Some virtual platforms provide advanced features such as \dvttermreverseexecution \dvtcmdcitebib[p.~30,~31]{publications:leupers:2010} (the ability to run a simulation backwards) and \dvttermcheckpointing \dvtcmdcitebib[p.~28,~29]{publications:leupers:2010} (functionality to save- and restore the state of a simulation).
These features are useful for debugging and testing a diverse range of software; from firmware to end-user applications\dvtcmdcitebib[p.~25]{publications:leupers:2010}.

There are several techniques to provide fast functional virtual platforms that are running \dvttermcpu -bound workloads. Typical methodologies include \dvtterminterpretation \dvtcmdcitebib[p.~35]{journals:smith:2005} (slowest), \dvttermjit\ compilation\dvtcmdcitebib[p.~24,~25]{journals:aarno:2013}, and \dvttermdirectvirtualization \dvtcmdcitebib[p.~24,~25]{journals:aarno:2013} (fastest)\dvtcmdcitebib[p.~38,~39]{publications:leupers:2010}.
Virtual platforms using these techniques can typically achieve a simulation performance in the range of \dvtcmdnum{10}-\dvtcmdnum{1000} \dvttermmipsecond\ \dvtcmdcitebib[p.~24,~25]{journals:aarno:2013}, but there is recorded performance of up to \dvtcmdnum{5000} \dvttermmipsecond \dvtcmdcitebib[p.~38,~39]{publications:leupers:2010}.\\

\noindent
The \dvttermgpu\ has become a vital part in delivering good user experience on many types of devices ranging from wearable, handheld, and portable units to desktop computers\todo{Statement require citation?}.
In contrast to \dvttermcpu -bound workloads, when developing \dvttermgpu\ kernels, seemingly insignificant additions to code may cause significant changes in performance due to massively parallelized instruction sets (see Performance~Considerations by Kirk~\&~Hwu\dvtcmdcitebib[ch.~6]{publications:kirk:2010} for an analysis on the volatility of \dvttermgpu\ performance).
Since \dvttermgpu s operate significantly different from \dvttermcpu s, they pose unique challenges to designers and developers (see Parallel~Programming~and~Computational~Thinking by Kirk~\&~Hwu\dvtcmdcitebib[ch.~13]{publications:kirk:2010} for an elaboration on \dvttermgpgpu\ methodology).
The increased utilization of \dvttermgpu s for general purpose workloads has extended the need for virtualization of such hardware in situations when hardware is busy, unavailable, not sufficient, or for the purposes of debugging \& profiling\footnote{An example of modern technology developed for said purposes is \dvttermwarp\ - \dvttermmicrosoft s latest addition to the \dvttermdirectx\ framework (see \dvtcmdciteref{web:microsoft:2013:warp}).}.
Yet seemingly few virtual platforms support virtualization of \dvttermgpu s, despite their influence on modern computing.\\

\noindent
For the purposes of simulation, different solutions follow varying use-cases. For example, developers interested in benchmarking or driver development for next generation \dvttermgpu - or \dvttermcpu s may need detailed simulators that provide insight into execution engines and pipelines\dvtcmdcitebib[p.~1]{inproceedings:schumacher:2010}.
Albeit useful in certain use-cases and capable of running 'toy' applications, such platforms are often orders of magnitude too slow to run commercial workloads\dvtcmdcitebib[p.~50]{journals:magnusson:2002}.
Application developers, on the other hand, do not necessarily care for the internal workings of hardware as they typically work at a higher abstraction level, for example; utilizing a graphics \dvttermapi\ (such as \dvttermopengl ) that, in turn, communicate with the device driver.
As such, application developers may be more interested in achieving decent simulation performance rather than a timing-accurate processor model (see \dvtcmdcitebib[p.~30]{publications:leupers:2010} for an analysis of compromises in system simulation).
However, due to large differences in-between \dvttermcpu - and \dvttermgpu -architecture, simply delegating commonly \dvttermgpu -bound workloads to the \dvttermhost\ \dvttermcpu\ is rarely feasible in terms of performance.\todo{Refer to dv2549?}

Common approaches to achieve better simulation performance includes creating a functionally accurate model of the \dvttermgpu\ (inducing the advantage of being able to utilize the same software [drivers, libraries, etc.] as the \dvttermhost\ platform), where internal details may be simplified, or using \dvttermsoftwarerendering\ without involving the \dvttermgpu\ model.
However, these methodologies traditionally incur heavy performance losses in comparison to \dvttermgpu\ hardware acceleration.
In order to achieve better performance, one may offload such kernels to the \dvttermgpu\ of the simulation \dvttermhost .
There are a number of way to achieve such acceleration, such as relying on \dvttermpcipassthrough\ and similar technologies to grant access to the underlying \dvttermhost\ hardware from within the virtual platform\dvtcmdcitebib[p.~415,~416]{inproceedings:regola:2010} (see \dvtcmdciteref{web:jones:2009} for an overview on \dvttermpcipassthrough ), or introducing a concept commonly referred to as '\dvttermparavirtualization ' at a higher level of abstraction (e.g., the \dvttermopengl\ library).

Paravirtualization is a relatively new term originally defined as selectively modifying the virtual architecture to enhance scalability, performance, and simplicity\dvtcmdcitebib[p.~165-166]{magazines:bartholomew:2006}.
Effectively, this means modifying the virtual machine to be similar, but not identical, to the simulated hardware\dvtcmdcitebib[p.~165]{journals:barham:2003}.
As such, one may simplify the virtualization process by neglecting some hardware compatibility\dvtcmdcitebib[p.~1]{inproceedings:youseff:2006}.
Implementing \dvttermgpu\ simulation by the means of \dvttermparavirtualization\ provides the benefits of improved simulation performance, albeit it may entail loosing some of the benefits a virtual platform can provide.
For example, it may be challenging to support advanced features such as \termdeterministicexecution , \dvttermcheckpointing , and \dvttermreverseexecution .
Additionally, paravirtualization entail erronous hardware simulation since kernel drivers are modified to accommodate the paravirtualized solution.
Yet, aforementioned technique is the preferred method of \dvttermgoogle\ in the \dvttermandroidsdk\ when utilizing the \dvttermqemu\ virtual platform in order to simulate \dvttermopengles .\\

\noindent
This proposal suggests - pursuant to  modern-day influence of \dvttermgpu\ technologies and the increasing need for extended virtual platforms - investigation into \dvttermparavirtualization\ of \dvttermopengles\ in the \dvttermsimics\ virtual platform, in accordance to the methodology used by \dvttermgoogle\ in the \dvttermandroidsdk .

As such, in accordance to The~2012~\dvttermacm ~Computing~Classification~System, proposed study concerns the fields of virtual~machines, graphics systems and interfaces,  and graphics~processors, respectively. Additionally, proposed study concerns, likewize in accordance to The~2012~\dvttermacm ~Computing~Classification~System, \dvttermintel .
%The remainder of this document presents the objectives-, question~formulations thereof-, suggested procedure, predicted risks, and the time~plan of proposed study.
%Implementational details and a breakdown structure is presented under \dvtcmdrefname{cha:appendixa}.
