% thesisappendixa.tex
% Chapter Appendix A.

% TODO: Add section on determinism in OpenGL ES solution from Proposal document.

% Appendix A
\chapter*{Appendix A}
\label{cha:appendixa}
\addcontentsline{toc}{chapter}{Appendix A}

% Simics
\section*{Simics}
\label{sec:appendixa_simics}
\addcontentsline{toc}{section}{Simics}
\index{Simics}
% Describe the background of simics
Simics is a \glslink{dvtglossfullsystemsimulation}{full-system simulator} developed by \dvttermintel\ and sold through \dvttermintel s subsidiary \dvttermwindriver\
Simics was originally developed by the simulation group at the \dvttermsics\ (this being the first instance of an academic group running an unmodified \dvttermos\ in an entirely simulated environment) including \dvttermgoogle s Peter S. Magnusson; the members of which founded \dvttermvirtutech \footnote{Virtutech was aquired by \dvttermintel\ in \dvtcmdnum{2010}\dvtcmdciteref{web:miller:2010}.} and commercially launched the product in \dvtcmdnum{1998}\dvtcmdcitebib{journals:magnusson:2013}.\\

\noindent
As an architectural simulator, \dvttermsimics\ primary client group is software- and systems developers that produce an assortment of software for complex systems involving software and hardware interaction\dvtcmdcitebib{journals:aarno:2013}.
As such, key attributes of \dvttermsimics\ are scalability, repeatability, and high-performance simulation.
For these purposes, the simulator supports \dvttermhostvirtualizationextensions , and other performance boosting technologies such as \dvttermhypersimulation \dvtcmdcitebib[p.~38]{publications:leupers:2010}.

Simics also features a number of advanced functionalities, adhering to the deterministic nature of the simulator, such as \dvttermcheckpointing\ (see section \dvtcmdrefname{sec:appendixa_checkpointing}) and \dvttermreverseexecution\ (see section \dvtcmdrefname{sec:appendixa_reverseexecution})\dvtcmdcitebib{publications:leupers:2010}.\\

\noindent
The ability to simulate the entirety of an unmodified software stack has led to Simics being used to simulate a variety of systems including, but not limited to, single-processor embedded boards, multiprocessor servers, and heterogeneous telecom clusters\dvtcmdcitebib{journals:aarno:2013}.

Current employers of the \dvttermsimics\ full-system simulator include, but are not limited to, \dvttermibm \dvtcmdcitebib[p.~12:1,~12:6]{journals:koerner:2009}, \dvttermnasa \dvtcmdciteref{web:windriver:2014}\dvtcmdciteref{web:nasa:2014}, and \dvttermintel \dvtcmdcitebib[p.~100]{journals:veselyi:2013}.
Other past and current employers of the simulator include \dvttermsunmicrosystems , \dvttermericsson , and \dvttermhewlettpackard \dvtcmdcitebib{journals:magnusson:2013}, in addition to \dvttermcisco , \dvttermfreescalesemiconductor , \dvttermgeavionics , \dvttermhoneywell , \dvttermlockheedmartin , \dvttermnortel\ and \dvttermnorthropgrumman\ \dvtcmdciteref{web:miller:2010}.

Additionally, the simulator has a strong academic tradition; being known to operate in over \dvtcmdnum{300} universities throughout the world\dvtcmdcitebib[p.~252]{journals:villa:2005}.

% Checkpointing
\section*{Checkpointing}
\label{sec:appendixa_checkpointing}
\addcontentsline{toc}{section}{Checkpointing}
\index{Checkpointing}

The state of a computer system may be defined as the entirety of its stored information, or memory, at a given time\dvtcmdcitebib[p.~103]{publications:harris:2007}.
It may be benificial to store such states in a '\dvttermcheckpointrestart ' scheme, as suggested by Jiang et al. in regards to \dvttermcuda\ kernels\dvtcmdcitebib[p.~196-197,~210]{inproceedings:zhang:2013}.
In this way, developers may save- and restore the state of a system which can reduce overhead of restarting computationally heavy applications from scratch\dvtcmdcitebib[p.~19,~20]{journals:aarno:2013}.

In \dvttermsimics , '\dvttermcheckpointing ' refers to the functionality to save the complete state of a simulation into a portable format.
When applied, this format is known as a \dvttermcheckpoint .
This ability not only  saves time in terms of program initialization and debugging\dvtcmdcitebib[p.~54]{journals:magnusson:2002}, but may also ease testing and collaboration in-between developers as \dvttermcheckpoint s may be distributed and shared\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2013:collaboratingusingsimics} for an overview on \dvttermcheckpointing\ in \dvttermsimics ).
As such, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermcheckpointing\ denotes said functionality.

% Deterministic Execution
\section*{Deterministic Execution}
\label{sec:appendixa_deterministicexecution}
\addcontentsline{toc}{section}{Deterministic Execution}
\index{Deterministic Execution}

\glslink{dvtglossdeterministicexecution}{'Deterministic execution'} commonly refers to the execution of \dvttermdeterministicalgorithm s; meaning that a certain function, given a definite input, will produce a decisive output - throughout the process in which the system passes through a distinct set of states (see \dvtcmdcitebib{journals:cohen:1979} for an overview on \glslink{dvtglossdeterministicalgorithm}{deterministic- and non-deterministic algorithms}).
Some sources have voiced concerns over the consequences, in terms of debugging, of non-deterministic behaviour caused by concurrent software\dvtcmdcitebib[p.~3-5]{journals:lee:2006}\dvtcmdcitebib[p.~92]{journals:holzmann:1997}.
Some even go as far as to argue that determinism is a prerequisite for effective debugging and testing\dvtcmdcitebib[p.~3,~4]{dissertation:devietti:2012}\dvtcmdcitebib[p.~51,~59]{inproceedings:yu:2012}.
As such, deterministic behaviour may be seen as a valuable attribute in a virtual platform (see \dvtcmdcitebib[p.~1,~2]{papers:bergan:2011} for an overview on the value of determinism in software development).

In \dvttermsimics , '\dvttermdeterministicexecution ' denotes the entire \dvttermtarget\ system as a \dvttermdeterministicalgorithm , wherein all instructions are executed in a deterministic manner on the simulated hardware\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013}.
This means that the simulated system (e.g., an \dvttermos ), presuming the same input, will allocate the same memory space in virtual memories, receive the same number of interrupts in sequence, and even inhabit the same registers in virtual \dvttermcpu s\dvtcmdcitebib[p.~19,~20]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2012:determinism} for a brief rundown of \dvttermdeterministicexecution\ in \dvttermsimics ).
As such, given an arbitrary number of instructions, the simulation state may be recreated indiscriminately down to the level of the instruction set and corresponding cycles.
Thus, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermdeterministicexecution\ refers to the deterministic state transition of a \dvttermtarget\ system; as described in this paragraph.

% Reverse Execution
\section*{Reverse Execution}
\label{sec:appendixa_reverseexecution}
\addcontentsline{toc}{section}{Reverse Execution}
\index{Reverse Execution}

\glslink{dvtglossreverseexecution}{'Reverse execution'} provides software developers with the ability to return, often from portable \dvttermcheckpoint s, to previous states of execution\dvtcmdcitebib[p.~2,~3]{journals:akgul:2004}.
This may be useful when debugging, profiling, or testing as difficult-to-reach system states may be stored and returned to, effectively bypassing program initialization and other hindrances\dvtcmdcitebib[p.~54]{journals:magnusson:2002}.

In \dvttermsimics , '\dvttermreverseexecution ' denotes said ability - covering the entirety of the simulated system\dvtcmdcitebib[p.~30,~31]{publications:leupers:2010}.
As such, simulated systems may be run in reverse; including virtualized hardware device states, disk contents and \dvttermcpu\ registers\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2013:backtorevexe} for an overview on \dvttermreverseexecution\ in \dvttermsimics ); whilst still maintaining determinism in the simulated system.
As such, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermreverseexecution referse to the functionality described in this section.

% Reference Solution
\section*{Reference Solution}
\label{sec:appendixa_referencesolution}
\addcontentsline{toc}{section}{Reference Solution}
\index{Reference Solution}
\index{Reference Implementation}

The \dvttermandroidemulator\ is described as a virtual mobile device emulator\dvtcmdciteref{web:google:2013:usingtheemulator}. Included in the \dvttermandroidsdk , it supports virtualization of an assortment of mobile hardware permutations.
In the presence of thet \dvttermandroid\ \dvtcmdnum{4.0.3} release, the \dvttermandroidsdk\ was updated to make use of hardware-assisted \dvttermxeightysix\ virtualization; significantly increasing performance of \dvttermcpu -bound workloads\dvtcmdciteref{web:ducrohet:2012:afasteremulator}.
In addition to this, \dvttermgoogle\ implemented \dvttermopengles\ \dvtcmdnum{1.1} \& \dvtcmdnum{2.0} hardware acceleration; offering a substantial performance boost to developers utilizing the \dvttermopengles\ framework\dvtcmdciteref{web:ducrohet:2012:afasteremulator}.
\dvttermgoogle 's solution, the design documents of which are attached in \dvtcmdcitefur{dissertation:nilsson:2014} (see \dvtcmdcitefur{technicaldocs:google:2014}), consists of a paravirtualized implementation which circumvents the simulated system by forwarding its \dvttermopengles\ invocations to the \dvttermhost\ system directly via the simulator program.

As of \dvttermandroid\ \dvtcmdnum{4.4}, the \dvttermandroidemulator\ uses \dvttermqemu\ to simulate \dvttermarm\ and \dvttermxeightysix\ devices aiding those wishing to develop software for mobile units.
The \dvttermandroidemulator\ implementation and solution are referred to as the \dvttermreferenceimplementation\ and the \dvttermreferencesolution , respectively, throughout this document.

% Magic Instructions
\section*{Magic Instructions}
\label{sec:appendixa_magicinstructions}
\addcontentsline{toc}{section}{Magic Instructions}
\index{Magic Instruction}
Sometimes during system simulation, there may be reasons as to why one would like to escape the simulation and resume execution in the real world.
Such a scenario would be a debugging breakpoint, to share data in-between \dvttermtarget\ and \dvttermhost\ systems, or for any reason modify the simulation state.
There are a number of ways to communicate with the outside world (including the \dvttermhost\ machine) from within the simulation, such as by networking means or specially devised kernel drivers, but few are as instant as the - arguably - legitimately coined '\dvttermmagicinstruction '.

The \dvttermmagicinstruction s a concept used to denote a \dvtcmdcodeinline{nop}-type instruction, meaning an instruction that would have no effect if run on the \dvttermtarget\ architecture (such as \dvtcmdcodeinline{xchg ebx, ebx}\footnote{'Swap contents in registers \dvtcmdcodeinline{ebx} and \dvtcmdcodeinline{ebx}'.} on the \dvttermxeightysix -architecture), which - when executed on the simulated hardware in a virtual platform - invokes a certain callback-method\dvtcmdcitebib[p.~32]{publications:leupers:2010}.
An advantage of this methodology is an often negligible invocation cost, as the context switch is often instant from the perspective of the \dvttermtarget\ system\dvtcmdcitebib[p.~131]{journals:rechistov:2013}.
Furthermore, and a greatly desireable attribute, \dvttermmagicinstruction s require no modification of the \dvttermtarget\ system.
Another advantage of the \dvttermmagicinstruction\ paradigm is that the system invoking such an instruction may, without complications, run outside of a simulation - as this would simply result in regular \dvtcmdcodeinline{nop}-behaviour.

In effect, implementation of \dvttermmagicinstruction s requires replacing one- or more instructions in the \dvttermtarget\ instruction set; thereby making the \dvttermmagicinstruction\ platform-dependent.
However, the solution is often designed to only respond to \dvttermmagicinstruction s wherein a certain magic number, sometimes called a 'leaf number'\dvtcmdcitebib[p.~131]{journals:rechistov:2013}, is present in an arbitrary processor register.

% TODO: Consider inserting Determinism in OpenGL ES section from Proposal:
%\section*{Determinism in \termopengles }
%\label{sec:appendixa_determinisminopengles}
%\addcontentsline{toc}{section}{Determinism in \termopengles }
%Following an \termapi\ specification such as \termopengles , it naturally follows that there may be implementational differences in-between vendor drivers.
%Such variations are commonly insignificant and, although present, do not affect the end-user.
%Below, presuming the occurence of such inconsistencies, a number of scenarios are presented in order to explain how this may affect the desireable traits of the \termsimics\ full-system simulator whilst simulating \termopengles .\\

%\noindent
%In line with driver inconsistencies, there may be cause to belive that rounding of pixel values may vary dependent on \termhost\ driver vendor.
%Typically, such variations are far from noticable and would not offset simulation timing.
%Neither would this inconsequential execution affect the local deterministic trait during simulation, as the driver in itself is coherent in its execution.

%In \termsimics , determinism and repeatability are key values, meaning that simulation execution must not differ - independant on the \termhost\ system.
%For example, one may pose the scenario of \termsimics\ users, using different driver vendors on their respective \termhost\ machines, wishing to share \termcheckpoint s in which an application utilizing \termopengles\ is being executed.
%In this manner, posing that the execution paths of said application treads on functionality that is not intricately defined by the \termopengles\ specification, the output may differ.
%Note that, presuming the output (usually a buffer to-be presented on-screen) is not calculated upon, this does not affect the \termtiming\ of the users' simulations.
%As such, this scenario maintains the determinism and repeatability traits of \termsimics .

%However, if this varying output is calculated upon (a plausible scenario would be the compression of a graphics output screenshot) the \termtiming\ of simulation is influenced which may propogate - effectively causing a state-change in the simulated \termcpu .
%In this manner, the deterministic trait of \termsimics\ would be broken, as certain instructions no longer correspond to their previously \termtiming -accurate cycles.

