% thesisappendixa.tex
% Chapter Appendix A.

% TODO: Add section on determinism in OpenGL ES solution from Proposal document.

% Appendix A
\chapter*{Appendix A}
\label{cha:appendixa}
\addcontentsline{toc}{chapter}{Appendix A}

% Virtual Time
\section*{Virtual Time}
\label{sec:appendixa_virtualtime}
\addcontentsline{toc}{section}{Virtual Time}
\index{Virtual Time}
\ldots

% Reverse Execution
\section*{Reverse Execution}
\label{sec:appendixa_reverseexecution}
\addcontentsline{toc}{section}{Reverse Execution}
\index{Reverse Execution}

\glslink{dvtglossreverseexecution}{'Reverse execution'} provides software developers with the ability to return, often from portable \dvttermcheckpoint s, to previous states of execution\dvtcmdcitebib[p.~2,~3]{journals:akgul:2004}.
This may be useful when debugging, profiling, or testing as difficult-to-reach system states may be stored and returned to, effectively bypassing program initialization and other hindrances\dvtcmdcitebib[p.~54]{journals:magnusson:2002}.

In \dvttermsimics , '\dvttermreverseexecution ' denotes said ability - covering the entirety of the simulated system\dvtcmdcitebib[p.~30,~31]{publications:leupers:2010}.
As such, simulated systems may be run in reverse; including virtualized hardware device states, disk contents and \dvttermcpu\ registers\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2013:backtorevexe} for an overview on \dvttermreverseexecution\ in \dvttermsimics ); whilst still maintaining determinism in the simulated system.
As such, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermreverseexecution referse to the functionality described in this section.

% Reference Solution
\section*{Reference Solution}
\label{sec:appendixa_referencesolution}
\addcontentsline{toc}{section}{Reference Solution}
\index{Reference Solution}
\index{Reference Implementation}

The \dvttermandroidemulator\ is described as a virtual mobile device emulator\dvtcmdciteref{web:google:2013:usingtheemulator}. Included in the \dvttermandroidsdk , it supports virtualization of an assortment of mobile hardware permutations.
In the presence of thet \dvttermandroid\ \dvtcmdnum{4.0.3} release, the \dvttermandroidsdk\ was updated to make use of hardware-assisted \dvttermxeightysix\ virtualization; significantly increasing performance of \dvttermcpu -bound workloads\dvtcmdciteref{web:ducrohet:2012:afasteremulator}.
In addition to this, \dvttermgoogle\ implemented \dvttermopengles\ \dvtcmdnum{1.1} \& \dvtcmdnum{2.0} hardware acceleration; offering a substantial performance boost to developers utilizing the \dvttermopengles\ framework\dvtcmdciteref{web:ducrohet:2012:afasteremulator}.
\dvttermgoogle 's solution, the design documents of which are attached in \dvtcmdcitefur{dissertation:nilsson:2014} (see \dvtcmdcitefur{technicaldocs:google:2014}), consists of a paravirtualized implementation which circumvents the simulated system by forwarding its \dvttermopengles\ invocations to the \dvttermhost\ system directly via the simulator program.

As of \dvttermandroid\ \dvtcmdnum{4.4}, the \dvttermandroidemulator\ uses \dvttermqemu\ to simulate \dvttermarm\ and \dvttermxeightysix\ devices aiding those wishing to develop software for mobile units.
The \dvttermandroidemulator\ implementation and solution are referred to as the \dvttermreferenceimplementation\ and the \dvttermreferencesolution , respectively, throughout this document.

% Determinism in OpenGL ES
\section*{Determinism in OpenGL ES}
\label{sec:appendixa_determinisminopengles}
\addcontentsline{toc}{section}{Determinism in OpenGL ES}
Following an \dvttermapi\ specification such as \dvttermopengles , it naturally follows that there may be implementational differences in-between vendor drivers.
Such variations are commonly insignificant and, although present, do not affect the end-user.
Below, presuming the occurence of such inconsistencies, a number of scenarios are presented in order to explain how this may affect the desireable traits of the \dvttermsimics\ full-system simulator whilst simulating \dvttermopengles .\\

\noindent
In line with driver inconsistencies, there may be cause to belive that rounding of pixel values may vary dependent on \dvttermhost\ driver vendor.
Typically, such variations are far from noticable and would not offset simulation timing.
Neither would this inconsequential execution affect the local deterministic trait during simulation, as the driver in itself is coherent in its execution.

In \dvttermsimics , determinism and repeatability are key values, meaning that simulation execution must not differ - independant on the \dvttermhost\ system.
For example, one may pose the scenario of \dvttermsimics\ users, using different driver vendors on their respective \dvttermhost\ machines, wishing to share \dvttermcheckpoint s in which an application utilizing \dvttermopengles\ is being executed.
In this manner, posing that the execution paths of said application treads on functionality that is not intricately defined by the \dvttermopengles\ specification, the output may differ.
Note that, presuming the output (usually a buffer to-be presented on-screen) is not calculated upon, this does not affect the \dvttermtiming\ of the users' simulations.
As such, this scenario maintains the determinism and repeatability traits of \dvttermsimics .

However, if this varying output is calculated upon (a plausible scenario would be the compression of a graphics output screenshot, such as the ones presented in section \ref{sec:methodologyexperiment_benchmarking}) the \dvttermtiming\ of simulation is influenced which may propogate - effectively causing a state-change in the simulated \dvttermcpu .
In this manner, the deterministic trait of \dvttermsimics\ would be broken, as certain instructions no longer correspond to their previously \dvttermtiming -accurate cycles.

