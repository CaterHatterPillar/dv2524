% thesisfuturework.tex
% Chapter Future Work.

% Future Work
\chapter{Future Work}
\label{cha:futurework}
The solution devised for the purpose of this study may be advanced in a number of ways in order to support higher variations in differing platforms, automation in \dvttermabi\ generation, an array of performance improvements, and general enhancements to make the paravirtualized solution more flexible during maintinence.
Additionally, in consideration to incorporation of a graphics acceleration solution - such as the one presented in this dissertation - into the \dvttermsimics\ full-system simulator, the solution must be improved in terms of cross-platform capabilites.
Recommendations for future work in terms of integration into the \dvttermsimics\ environment is presented in section \ref{sec:futurework_simicsproductification}.

Below, recommendations for future study, in terms of the experiment performed for the purposes of this thesis, are presented.\\

\noindent

% TODO:
% Benchmarking accuracy
% Profiling accuracy
% Profilation of memory table traversal
% Mini-benchmark stressing communication bandwidth, without causing cache misses by redundant rendering.
% Further investigation
% Heavier graphics benchmarking. The benchmarks presented for this study have effectively been mini-benchmarks, stressing particular bottlenecks in the solution. In line with chapter Rweults and conclusuons having concluded parabvrtualization as feasbile for the means of acceleration ghraphjiocs in virtual platforms, this ought be investigated further with heavier benchmarking in order to more efgfectivelty establish the magnitude of performance hains a paravirtualized solution may achieve.
% This includes study into the great performance achieved by the QEMU-derived android emulator.

\ldots

% Advanced Functionality
\section{Simics Productification}
\label{sec:futurework_simicsproductification}
For the purposes of productification of a graphics acceleration solution, as presented in this document, necessary improvements include endianness\footnote{Which is, at the time of writing, assumed to be of little endian order.} consideration in the communication in-between \dvttermtarget - and \dvttermhost\ libraries, in addition to floating point format\footnote{Which is, at the time of writing, assumed to be that of \dvttermieeefp .}.
If paravirtualization were to used for accelerating graphics in the \dvttermsimics\ full-system simulator, one would have to support such \dvttermtarget - and \dvttermhost\ as it is not all uncommon that these platforms differ.
After all, clients often wish to simulate other platforms than those they currently posess.

Another cross-platform issue, that comes to mind when interfering with the \dvttermtarget\ physical memory from outside simulation, is that is \glslink{dvtglossmemorypagelocking}{memory page locking}.
Such functionalities sometimes limited in some operating systems; albeit entirely controlled by the user in \dvttermlinux\ derived systems.
\glslink{dvtglosstarget}{Target} system platform differences such as these may incur performance hindrances in that the amount of memory that may be \glslink{dvtglossmemorypagelocking}{locked} could be limited; forcing the solution to perform its bytestream transmission in several instances of \dvttermmagicinstruction s.
Furthermore, \glslink{dvtglossmemorypagelocking}{page locking} functionalities may not be accessible by the user whatsoever, suggesting further studies into how a paravirtualized solution for graphics acceleration may perform using other methodologies for trans-simulation communication; such as TCP/IP-networking (see \dvtcmdcitefur{dissertation:nilsson:2014} for an elaboration on such methodologies).

In section \ref{sec:background_graphicsvirtualization}, potentially costly maintenance of updated graphics frameworks is mentioned as drawback of paravirtualization as a methodology to achieve graphics acceleration.
Later, in section \ref{sec:methodologysolution_openglabigeneration}, it is mentioned that the solution described in document utilizes software to partly generate paravirtualized graphics \dvttermabi s where possible.
In order to further streamline the maintenance of a productified paravirtualized solution, such framework generation could be automated further by utilizing software such as \texttt{SWIG} or \texttt{SIL} to retrieve function signatures; no longer requiring developers to describe function headers by the means of configuration files as described in section \ref{sec:methodologysolution_openglabigeneration}.

Furthermore, in line with the \dvttermsimics\ attributes described in chapter \ref{cha:background}, a certain set of behaviour must be attained in order to align with \dvttermsimics\ philosophy.
Analyses and recommendations surrounding further study of said attributes, in terms of graphics acceleration by the means of paravirtualization, are presented below in paragraphs \dvtcmdrefname{par:futurework_simicsproductification_deterministicexecution}, \dvtcmdrefname{par:futurework_simicsproductification_checkpointing}, and \dvtcmdrefname{par:futurework_simicsproductification_reverseexecution}, respectively.

% Deterministic Execution (section Determinism in OpenGL ES)
\paragraph{Deterministic Execution}
\label{par:futurework_simicsproductification_deterministicexecution}
\index{Deterministic Execution}
\ldots

Following an \dvttermapi\ specification such as \dvttermopengles , it naturally follows that there may be implementational differences in-between vendor drivers.
Such variations are commonly insignificant and, although present, do not affect the end-user.
Below, presuming the occurence of such inconsistencies, a number of scenarios are presented in order to explain how this may affect the desireable traits of the \dvttermsimics\ full-system simulator whilst simulating \dvttermopengles .\\

\noindent
In line with driver inconsistencies, there may be cause to belive that rounding of pixel values may vary dependent on \dvttermhost\ driver vendor.
Typically, such variations are far from noticable and would not offset simulation timing.
Neither would this inconsequential execution affect the local deterministic trait during simulation, as the driver in itself is coherent in its execution.

In \dvttermsimics , determinism and repeatability are key values, meaning that simulation execution must not differ - independant on the \dvttermhost\ system.
For example, one may pose the scenario of \dvttermsimics\ users, using different driver vendors on their respective \dvttermhost\ machines, wishing to share \dvttermcheckpoint s in which an application utilizing \dvttermopengles\ is being executed.
In this manner, posing that the execution paths of said application treads on functionality that is not intricately defined by the \dvttermopengles\ specification, the output may differ.
Note that, presuming the output (usually a buffer to-be presented on-screen) is not calculated upon, this does not affect the \dvttermtiming\ of the users' simulations.
As such, this scenario maintains the determinism and repeatability traits of \dvttermsimics .

However, if this varying output is calculated upon (a plausible scenario would be the compression of a graphics output screenshot, such as the ones presented in section \ref{sec:methodologyexperiment_benchmarking}) the \dvttermtiming\ of simulation is influenced which may propogate - effectively causing a state-change in the simulated \dvttermcpu .
In this manner, the deterministic trait of \dvttermsimics\ would be broken, as certain instructions no longer correspond to their previously \dvttermtiming -accurate cycles.

% Checkpointing
\paragraph{Checkpointing}
\label{par:futurework_simicsproductification_checkpointing}
\index{Checkpointing}
\ldots

% Reverse execution
\paragraph{Reverse Execution}
\label{par:futurework_simicsproductification_reverseexecution}
\index{Reverse Execution}
\ldots

\section{API Extensions}
\label{sec:futurework_apiextensions}
\ldots

% TODO:
% Use case scenario of existing GL libraries on the host machine - but DX libraries on the target system. Is translation possible (bring up Valve ToGL-project)?
%Speculate surrounding possible use-case in which the target system has DirectX whereas the host machine sits on OpenGL and wants to accelerate target system graphics using paravirtualization.

% Safety Critical solutions:
%A number of possibilities present themselves in terms of safety critical OpenGL utilization, as a paravirtualization can make certain changes to how methods are invoked - without having to modified the application in-and-of-itself. Such a scenario would be to disable all vertex attributes not enabled specifically, each frame.