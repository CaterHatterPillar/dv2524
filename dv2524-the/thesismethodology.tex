% thesismethodology.tex
% Chapter Methodology.

% Methodology:
\chapter{Methodology}
\label{cha:methodology}
The implementation constitutes the realization of the paravirtualized technology described in this document and corresponding thesis proposal (see \dvtcmdcitefur{dissertation:nilsson:2014}).
Throughout this document, several concepts and phrases may be recognized and related to the Android Hardware OpenGL ES emulation design overview (see \dvtcmdcitefur{technicaldocs:google:2014}).

%In accordance to said \dvttermreferenceimplementation , this dissertation suggests achieving acceleration of \dvttermopenglestwopointo\ by implementing an acceleration pipeline consisting of three stages that are, in turn, supported by a specialized communications channel in \dvttermsimics .
%Moreover, said communications channel, or '\termsimicspipe ', utilizes a specially devised protocol to describe an assortment of \termopengles\ and \termegl\ function calls when sent in-between the \termhost - and \termtarget\ systems (\dvcmdrefappa{sec:appendixa_simicspipeprotocol}).

% Experiment Methodology:
\section{Experiment Methodology}
\label{sec:methodology_experimentmethodology}
Throughout the course of the pilot study, no existing \dvttermopenglestwopointo\ benchmark - with cross-platform profiling support for \dvttermandroid\ and \dvttermxeleven\ \dvttermlinux\ - was deemed appropriate for for the purposes of this dissertation (see \dvtcmdcitefur{dissertation:nilsson:2014} for an elaboration on said inquiry).
As such, a benchmark has been devised on-site for the purposes of stress-testing the solution developed for the purpose of this study.
The benchmark consists of three seperate tests; each intended to stress suspected bottlenecks in the implementation; corresponding to a large number of relatively insignificant \dvttermopengl\ invocations, computationally intensive \dvttermgpu\ kernels, and passing of large data such as textures or models (see \dvtcmdcitefur{dissertation:nilsson:2014} for an elaboration on the ambitions and motives for said benchmark).
The benchmark, intended to run on a \dvttermhost\ \dvttermfedora\ \dvttermlinux\ system, a virtualized \dvttermsimics\ \dvttermfedora\ configuration, and a \dvttermqemu\ \dvttermandroid\ configuration, utilizes \dvttermjni\ to invoke \dvttermopengles\ from the same \dvttermc\ code base independent of platform; in line with the motives outlined in \dvtcmdcitefur{dissertation:nilsson:2014}.
Furthermore, all benchmarks have been configured to run at roughly \dvtcmdnum{16}~\milli\second\ (or roughly \dvtcmdnum{60}~\dvttermfps ) when hardware accelerated on the \dvttermhost\ system, in order to reflect the expected load of a modern real-time interactive system.
As such, the purpose of developed benchmarks is to be representative of typical scenarios induced by modern \dvttermgui s whilst utilizing a graphics framework such as \dvttermopengl .

The benchmarks are presented below:

% TODO: Preferably the benchmark images ought to be presented side-by-side, as to not take up too much space (remember, not vector graphics goodies).
\missingfigure[figwidth=6cm]{Side-by-side image of Chess benchmark output.} % TODO: Insert image of benchmark output.
\missingfigure[figwidth=6cm]{Side-by-side image of Chess benchmark output.} % TODO: Insert image of benchmark output.
\missingfigure[figwidth=6cm]{Side-by-side image of Chess benchmark output.} % TODO: Insert image of benchmark output.

\paragraph{Benchmark: Chess}
\label{par:methodology_experimentmethodology_benchmarkchess}
\index{Chess benchmark}
The 'Chess' benchmark is developed for the purposes of stressing the latency in-between \dvttermtarget - and \dvttermhost\ systems.
It is so named because of the chess-like tileset the graphics kernel produces (\todo{refer to figure}).
The benchmark is designed to perform a multitude of \dvttermopenglestwopointo\ library invocations per frame; in which each invocation is relatively lightweight in execution and carry a small amount of data argument-wize.
In the Chess benchmark, this is achieved by renderering a grid of colored (black or white, in order to adhere to the chess paradigm) rectangles where each tile is represented by four two-dimensional vertices in screen-space, in addition to six indices outlining the rectangular shape.
Since the vertices are already transformed into screen-space, the graphics kernel need perform no additional transformation, adhering to the desired lightweight behaviour of each kernel invocation.
Additionally, the tileset vertices and indices are pre-loaded into \dvttermopengl\ vertex- and index element buffers, so that a lone buffer identifier may be carried over in-place of the heavier vertex set load.
Each tile is then individually drawn to the backbuffer, rendering the chess-like appearance of the benchmark.

Effectively, this means that, for each tile, the benchmark need only bind a vertex- and an index element buffer, set the corresponding tile color, and lastly invoke the rendering of said tile.
The benchmark kernel in it's entirety is presented in section \dvtcmdrefname{sec:appendixb_benchmarkchesskernel} under \dvtcmdrefname{cha:appendixb}.

The repeated invocation of lesser draw calls is representative of common usage of drawing a multide of shapes with \dvttermopengl , such as a user interface. Additionally, the number of tiles being computed is easily modifiable; rendering the benchmark scalable for the purposes of the experiment described in this document. As such, said benchmark is considered suitable for the purpose of representing a large number of graphics invocations using \dvttermopenglestwopointo .

\paragraph{Benchmark: Julia}
\label{par:methodology_experimentmethodology_benchmarkjulia}
\index{Julia fractal benchmark}
The 'Julia' benchmark is developed for the purposes of stressing computational intensity in software-rasterized and paravirtualized platforms.
It is so named due to the kernel calculating the Julia fractal (\todo{refer to figure}); the texturing of which gives the benchmark it's distinct look.
The benchmark is designed to perform a lone computationally intensive graphics kernel invocation, which will stress the computational prowess of the profiled platform.
The case is selected for use as the computation of a fractal is trivially scalable in terms of complexity by modifying the number of iterations the fractal algorithm performs, and is thus considered suitable for profiling of computationally intensive graphics kernels.
Then benchark kernel in it's entirety is presented in section
\dvtcmdrefname{sec:appendixb_benchmarkjuliakernel} under \dvtcmdrefname{cha:appendixb}.

\paragraph{Benchmark: Phong}
\label{par:methodology_experimentmethodology_benchmarkphong}
\index{Phong shading benchmark}


%The rasterization and shading of a model with a given, large, texture is representative of graphics commonly rendered with OpenGL ES. As such, the Phong benchmark is suitable for the purposes of representing the usage of big data (models, textures, etc.). Figure out a way of easily scaling the Phong demo (rendering the teapot of various vertex resolutions, for example).
%Vertices and indices are transferred to the host system every frame. As such, the benchmark is not making use of vertex buffers; stressing the bandwidth in-between target and host.
Texture data also updated every frame.
Easily scalable by modifying size of texture and/or model.

\subsection{Platform Time Profiling}
\label{sec:methodology_experimentmethodology_platoformtimeprofiling}
\ldots

% Suggested structure:
% * Solution:
% * * Component A
% * * Component B
% * Experiment Methodology:
% * * Benchmarking
% * * Measurement and Reliability

% TODO:
% | Benchmarks
% | Experiment methodology:
% | * Measurement timing and reliability on the different systems.
% | Explenation of solution and it's components.

% Elaborate on how the experiment ought to be performed (i.e. on software rasterized simics and in what configuration). See below:

%The developed benchmark ought to execute on the studied platforms; being paravirtualized \termsimics , software~rasterized \termsimics , and the \termrefsolu , respectively.
%It is vital to sound experiment methodology that the tests performed throughout the benchmark focuses on critical areas and suspected bottlenecks in the implementation.
%Such key points during simulation may concern a large number of relatively insignificant \termopengles\ invocations, frame-wize \termopengles\ state saving, or transferral of large chunks of data such as textures.
%These areas may very well be bottlenecks of graphics paravirtualization and thus call for further investigation.
%Due to the proposed study accentuating performance, and since it concerns a graphics framework often used with real-time applications, it may be viable to measure experimental data in \termframespersecond ~(\termfps ).
%Alternatively, lone dispatch measurements could be used in coagency with \termframespersecond\ measurements.
%Additionally, it may be favorable if, during development of said benchmark, if the software could utilize the same code-base to invoke the \termopengles -libraries - independant of platform.
