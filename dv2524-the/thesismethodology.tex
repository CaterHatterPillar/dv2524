% thesismethodology.tex
% Chapter Methodology.

% Methodology:
\chapter{Methodology}
\label{cha:methodology}
The implementation constitutes the realization of the paravirtualized technology described in this document and corresponding thesis proposal (see \dvtcmdcitefur{dissertation:nilsson:2014}).
Throughout this document, several concepts and phrases may be recognized and related to the Android Hardware OpenGL ES emulation design overview (see \dvtcmdcitefur{technicaldocs:google:2014}).

%In accordance to said \dvttermreferenceimplementation , this dissertation suggests achieving acceleration of \dvttermopenglestwopointo\ by implementing an acceleration pipeline consisting of three stages that are, in turn, supported by a specialized communications channel in \dvttermsimics .
%Moreover, said communications channel, or '\termsimicspipe ', utilizes a specially devised protocol to describe an assortment of \termopengles\ and \termegl\ function calls when sent in-between the \termhost - and \termtarget\ systems (\dvcmdrefappa{sec:appendixa_simicspipeprotocol}).

% Experiment Methodology:
\section{Experiment Methodology}
\label{sec:methodology_experimentmethodology}
Throughout the course of the pilot study, no existing \dvttermopenglestwopointo\ benchmark - with cross-platform profiling support for \dvttermandroid\ and \dvttermxeleven\ \dvttermlinux\ - was deemed appropriate for for the purposes of this dissertation (see \dvtcmdcitefur{dissertation:nilsson:2014} for an elaboration on said inquiry).
As such, a benchmark has been devised on-site for the purposes of stress-testing the solution developed for the purpose of this study.
The benchmark consists of three seperate tests; each intended to stress suspected bottlenecks in the implementation; corresponding to a large number of relatively insignificant \dvttermopengl\ invocations, computationally intensive \dvttermgpu\ kernels, and passing of large data such as textures or models (see \dvtcmdcitefur{dissertation:nilsson:2014} for an elaboration on the ambitions and motives for said benchmark).
The benchmark, intended to run on a \dvttermhost\ \dvttermfedora\ \dvttermlinux\ system, a virtualized \dvttermsimics\ \dvttermfedora\ configuration, and a \dvttermqemu\ \dvttermandroid\ configuration, utilizes \dvttermjni\ to invoke \dvttermopengles\ from the same \dvttermc\ code base independent of platform; in line with the motives outlined in \dvtcmdcitefur{dissertation:nilsson:2014}.
The benchmarks are presented below:

% TODO: Preferably the benchmark images ought to be presented side-by-side, as to not take up too much space (remember, not vector graphics goodies).
\missingfigure[figwidth=6cm]{Side-by-side image of Chess benchmark output.} % TODO: Insert image of benchmark output.
\missingfigure[figwidth=6cm]{Side-by-side image of Chess benchmark output.} % TODO: Insert image of benchmark output.
\missingfigure[figwidth=6cm]{Side-by-side image of Chess benchmark output.} % TODO: Insert image of benchmark output.

\paragraph{Benchmark: Chess}
\label{par:methodology_experimentmethodology_benchmarkchess}
\index{Benchmark: Chess}
The 'Chess' benchmark is developed for the purposes of stressing the latency in-between \dvttermtarget - and \dvttermhost\ systems.
It is so named because of the chess-like tileset the graphics kernel produces (\todo{refer to figure}).
The benchmark is designed to perform a multitude of \dvttermopenglestwopointo\ library invocations per frame; in which each invocation is relatively lightweight in execution and carry a small amount of data argument-wize.
In the 'Chess' benchmark, this is achieved by renderering a grid of colored (black or white, in order to adhere to the chess paradigm) rectangles where each tile is represented by four two-dimensional vertices in screen-space, in addition to six indices outlining the rectangular shape.
Since the vertices are already transformed into screen-space, the graphics kernel need perform no additional transformation, adhering to the desired lightweight behaviour of each kernel invocation.
Additionally, the tileset vertices and indices are pre-loaded into \dvttermopengl\ vertex- and index element buffers, so that a lone buffer identifier may be carried over in-place of the heavier vertex set load.
Each tile is then individually drawn to the backbuffer, rendering the chess-like appearance of the benchmark.

Effectively, this means that, for each tile, the benchmark need only bind a vertex- and an index element buffer, set the corresponding tile color, and lastly invoke the rendering of said tile.
The benchmark kernel in it's entirety is presented in section \dvtcmdrefname{sec:appendixb_benchmarkchesskernel} under \dvtcmdrefname{cha:appendixb}.

\paragraph{Benchmark: Julia}
\label{par:methodology_experimentmethodology_benchmarkjulia}
\index{Benchmark: Julia}
Description of the Julia benchmark.


\paragraph{Benchmark: Phong}
\label{par:methodology_experimentmethodology_benchmarkphong}
\index{Benchmark: Phong}
The 'Phong' benchmark is developed for the purposes of stressing the throughput in-between \dvttermtarget - and \dvttermhost\ systems.

\subsection{Platform Time Profiling}
\label{sec:methodology_experimentmethodology_platoformtimeprofiling}
\ldots

% Suggested structure:
% * Solution:
% * * Component A
% * * Component B
% * Experiment Methodology:
% * * Benchmarking
% * * Measurement and Reliability

% TODO:
% | Benchmarks
% | Experiment methodology:
% | * Measurement timing and reliability on the different systems.
% | Explenation of solution and it's components.

% Elaborate on how the experiment ought to be performed (i.e. on software rasterized simics and in what configuration). See below:

%The developed benchmark ought to execute on the studied platforms; being paravirtualized \termsimics , software~rasterized \termsimics , and the \termrefsolu , respectively.
%It is vital to sound experiment methodology that the tests performed throughout the benchmark focuses on critical areas and suspected bottlenecks in the implementation.
%Such key points during simulation may concern a large number of relatively insignificant \termopengles\ invocations, frame-wize \termopengles\ state saving, or transferral of large chunks of data such as textures.
%These areas may very well be bottlenecks of graphics paravirtualization and thus call for further investigation.
%Due to the proposed study accentuating performance, and since it concerns a graphics framework often used with real-time applications, it may be viable to measure experimental data in \termframespersecond ~(\termfps ).
%Alternatively, lone dispatch measurements could be used in coagency with \termframespersecond\ measurements.
%Additionally, it may be favorable if, during development of said benchmark, if the software could utilize the same code-base to invoke the \termopengles -libraries - independant of platform.
