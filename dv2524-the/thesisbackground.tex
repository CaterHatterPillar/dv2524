% thesisbackground.tex
% Chapter Background.

% Background
\chapter{Background}
\label{cha:background}
\ldots

% In line with the research gaps entailed by section Related Work, the following research questions are considered to be lacking in the field...
% This dissertation sets out to contribute tot he field of computer science by answering these research questions in accordance to the aims and objectives outline in chapter...
% Contribution to computer science.


%Pursuant to the aim and objectives specified in \dvcmdrefcha{cha:aimandobjectives}, proposed study pertain to the concepts described in this \termcha .
%Accordingly, the key investigatory attributes and explicit research question formulations, sutiable for proposed study, are presented below.

%\newcommand*\researchquestionitem[2]{\item[#1:] \textit{#2}}
%\begin{multicols}{2}
%\begin{itemize*}
%	\researchquestionitem{1}{What are the benefits and disadvantages of paravirtualized graphics in virtual platforms?}
%	\researchquestionitem{2}{What are the prerequisites of \termdetexe\  of paravirtualized graphics in virtual platforms?}
%	\researchquestionitem{3}{What are the prerequisites of \termcheckpointing\ of paravirtualized graphics in virtual platforms?}
%	\researchquestionitem{4}{What are the prerequisites of \termrevexe\ of paravirtualized graphics in virtual platforms?}
%\end{itemize*}
%\end{multicols}

% Simics
\section*{Simics}
\label{sec:background_simics}
\addcontentsline{toc}{section}{Simics}
\index{Simics}
% Describe the background of simics
Simics is a \glslink{dvtglossfullsystemsimulation}{full-system simulator} developed by \dvttermintel\ and sold through \dvttermintel s subsidiary \dvttermwindriver\
Simics was originally developed by the simulation group at the \dvttermsics\ (this being the first instance of an academic group running an unmodified \dvttermos\ in an entirely simulated environment) including \dvttermgoogle s Peter S. Magnusson; the members of which founded \dvttermvirtutech \footnote{Virtutech was aquired by \dvttermintel\ in \dvtcmdnum{2010}\dvtcmdciteref{web:miller:2010}.} and commercially launched the product in \dvtcmdnum{1998}\dvtcmdcitebib{journals:magnusson:2013}.\\

\noindent
As an architectural simulator, \dvttermsimics\ primary client group is software- and systems developers that produce an assortment of software for complex systems involving software and hardware interaction\dvtcmdcitebib{journals:aarno:2013}.
As such, key attributes of \dvttermsimics\ are scalability, repeatability, and high-performance simulation.
For these purposes, the simulator supports \dvttermhostvirtualizationextensions , and other performance boosting technologies such as \dvttermhypersimulation \dvtcmdcitebib[p.~38]{publications:leupers:2010}.

Simics also features a number of advanced functionalities, adhering to the deterministic nature of the simulator, such as \dvttermcheckpointing\ (see section \dvtcmdrefname{sec:background_checkpointing}) and \dvttermreverseexecution\ (see section \dvtcmdrefname{sec:background_reverseexecution})\dvtcmdcitebib{publications:leupers:2010}.\\

\noindent
The ability to simulate the entirety of an unmodified software stack has led to Simics being used to simulate a variety of systems including, but not limited to, single-processor embedded boards, multiprocessor servers, and heterogeneous telecom clusters\dvtcmdcitebib{journals:aarno:2013}.

Current employers of the \dvttermsimics\ full-system simulator include, but are not limited to, \dvttermibm \dvtcmdcitebib[p.~12:1,~12:6]{journals:koerner:2009}, \dvttermnasa \dvtcmdciteref{web:windriver:2014}\dvtcmdciteref{web:nasa:2014}, and \dvttermintel \dvtcmdcitebib[p.~100]{journals:veselyi:2013}.
Other past and current employers of the simulator include \dvttermsunmicrosystems , \dvttermericsson , and \dvttermhewlettpackard \dvtcmdcitebib{journals:magnusson:2013}, in addition to \dvttermcisco , \dvttermfreescalesemiconductor , \dvttermgeavionics , \dvttermhoneywell , \dvttermlockheedmartin , \dvttermnortel\ and \dvttermnorthropgrumman\ \dvtcmdciteref{web:miller:2010}.

Additionally, the simulator has a strong academic tradition; being known to operate in over \dvtcmdnum{300} universities throughout the world\dvtcmdcitebib[p.~252]{journals:villa:2005}.

% TODO:
% Explain the concepts of simulation target- and host.

% Deterministic Execution
\section*{Deterministic Execution}
\label{sec:background_deterministicexecution}
\addcontentsline{toc}{section}{Deterministic Execution}
\index{Deterministic Execution}

\glslink{dvtglossdeterministicexecution}{'Deterministic execution'} commonly refers to the execution of \dvttermdeterministicalgorithm s; meaning that a certain function, given a definite input, will produce a decisive output - throughout the process in which the system passes through a distinct set of states (see \dvtcmdcitebib{journals:cohen:1979} for an overview on \glslink{dvtglossdeterministicalgorithm}{deterministic- and non-deterministic algorithms}).
Some sources have voiced concerns over the consequences, in terms of debugging, of non-deterministic behaviour caused by concurrent software\dvtcmdcitebib[p.~3-5]{journals:lee:2006}\dvtcmdcitebib[p.~92]{journals:holzmann:1997}.
Some even go as far as to argue that determinism is a prerequisite for effective debugging and testing\dvtcmdcitebib[p.~3,~4]{dissertation:devietti:2012}\dvtcmdcitebib[p.~51,~59]{inproceedings:yu:2012}.
As such, deterministic behaviour may be seen as a valuable attribute in a virtual platform (see \dvtcmdcitebib[p.~1,~2]{papers:bergan:2011} for an overview on the value of determinism in software development).

In \dvttermsimics , '\dvttermdeterministicexecution ' denotes the entire \dvttermtarget\ system as a \dvttermdeterministicalgorithm , wherein all instructions are executed in a deterministic manner on the simulated hardware\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013}.
This means that the simulated system (e.g., an \dvttermos ), presuming the same input, will allocate the same memory space in virtual memories, receive the same number of interrupts in sequence, and even inhabit the same registers in virtual \dvttermcpu s\dvtcmdcitebib[p.~19,~20]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2012:determinism} for a brief rundown of \dvttermdeterministicexecution\ in \dvttermsimics ).
As such, given an arbitrary number of instructions, the simulation state may be recreated indiscriminately down to the level of the instruction set and corresponding cycles.
Thus, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermdeterministicexecution\ refers to the deterministic state transition of a \dvttermtarget\ system; as described in this paragraph.

% Checkpointing
\section*{Checkpointing}
\label{sec:background_checkpointing}
\addcontentsline{toc}{section}{Checkpointing}
\index{Checkpointing}

The state of a computer system may be defined as the entirety of its stored information, or memory, at a given time\dvtcmdcitebib[p.~103]{publications:harris:2007}.
It may be benificial to store such states in a '\dvttermcheckpointrestart ' scheme, as suggested by Jiang et al. in regards to \dvttermcuda\ kernels\dvtcmdcitebib[p.~196-197,~210]{inproceedings:zhang:2013}.
In this way, developers may save- and restore the state of a system which can reduce overhead of restarting computationally heavy applications from scratch\dvtcmdcitebib[p.~19,~20]{journals:aarno:2013}.

In \dvttermsimics , '\dvttermcheckpointing ' refers to the functionality to save the complete state of a simulation into a portable format.
When applied, this format is known as a \dvttermcheckpoint .
This ability not only  saves time in terms of program initialization and debugging\dvtcmdcitebib[p.~54]{journals:magnusson:2002}, but may also ease testing and collaboration in-between developers as \dvttermcheckpoint s may be distributed and shared\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2013:collaboratingusingsimics} for an overview on \dvttermcheckpointing\ in \dvttermsimics ).
As such, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermcheckpointing\ denotes said functionality.

% Reverse Execution
\section*{Reverse Execution}
\label{sec:background_reverseexecution}
\addcontentsline{toc}{section}{Reverse Execution}
\index{Reverse Execution}

\glslink{dvtglossreverseexecution}{'Reverse execution'} provides software developers with the ability to return, often from portable \dvttermcheckpoint s, to previous states of execution\dvtcmdcitebib[p.~2,~3]{journals:akgul:2004}.
This may be useful when debugging, profiling, or testing as difficult-to-reach system states may be stored and returned to, effectively bypassing program initialization and other hindrances\dvtcmdcitebib[p.~54]{journals:magnusson:2002}.

In \dvttermsimics , '\dvttermreverseexecution ' denotes said ability - covering the entirety of the simulated system\dvtcmdcitebib[p.~30,~31]{publications:leupers:2010}.
As such, simulated systems may be run in reverse; including virtualized hardware device states, disk contents and \dvttermcpu\ registers\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2013:backtorevexe} for an overview on \dvttermreverseexecution\ in \dvttermsimics ); whilst still maintaining determinism in the simulated system.
As such, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermreverseexecution referse to the functionality described in this section.

% Magic Instructions
\section*{Magic Instructions}
\label{sec:background_magicinstructions}
\addcontentsline{toc}{section}{Magic Instructions}
\index{Magic Instruction}
Sometimes during system simulation, there may be reasons as to why one would like to escape the simulation and resume execution in the real world.
Such a scenario would be a debugging breakpoint, to share data in-between \dvttermtarget\ and \dvttermhost\ systems, or for any reason modify the simulation state.
There are a number of ways to communicate with the outside world (including the \dvttermhost\ machine) from within the simulation, such as by networking means or specially devised kernel drivers, but few are as instant as the - arguably - legitimately coined '\dvttermmagicinstruction '.

The \dvttermmagicinstruction s a concept used to denote a \dvtcmdcodeinline{nop}-type instruction, meaning an instruction that would have no effect if run on the \dvttermtarget\ architecture (such as \dvtcmdcodeinline{xchg ebx, ebx}\footnote{'Swap contents in registers \dvtcmdcodeinline{ebx} and \dvtcmdcodeinline{ebx}'.} on the \dvttermxeightysix -architecture), which - when executed on the simulated hardware in a virtual platform - invokes a certain callback-method\dvtcmdcitebib[p.~32]{publications:leupers:2010}.
An advantage of this methodology is an often negligible invocation cost, as the context switch is often instant from the perspective of the \dvttermtarget\ system\dvtcmdcitebib[p.~131]{journals:rechistov:2013}.
Furthermore, and a greatly desireable attribute, \dvttermmagicinstruction s require no modification of the \dvttermtarget\ system.
Another advantage of the \dvttermmagicinstruction\ paradigm is that the system invoking such an instruction may, without complications, run outside of a simulation - as this would simply result in regular \dvtcmdcodeinline{nop}-behaviour.

In effect, implementation of \dvttermmagicinstruction s requires replacing one- or more instructions in the \dvttermtarget\ instruction set; thereby making the \dvttermmagicinstruction\ platform-dependent.
However, the solution is often designed to only respond to \dvttermmagicinstruction s wherein a certain magic number, sometimes called a 'leaf number'\dvtcmdcitebib[p.~131]{journals:rechistov:2013}, is present in an arbitrary processor register.

% Virtual Time
\section*{Virtual Time}
\label{sec:background_virtualtime}
\addcontentsline{toc}{section}{Virtual Time}
\index{Virtual Time}
\ldots
