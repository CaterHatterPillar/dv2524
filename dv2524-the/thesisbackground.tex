% thesisbackground.tex
% Chapter Background.

% TODO:
% Consider merging proposal chapter Expected Outcomes with this chapter.

% Background
\chapter{Background}
\label{cha:background}
In line with the previous work in the area specified in chapter \ref{cha:relatedwork}, there has been no indication - in academic writing - of any pre-existing solution of paravirtualized graphics \dvttermapi s signifying \glslink{dvtglossdeterministicexecution}{deterministic} behaviour; paving the way for supporting \dvttermreverseexecution\ graphics.
Such functionality could simplify debugging, testing, and profiling of applications comprising some \dvttermgpu -bound workload; not limited to graphics- or \dvttermgpu\ utilization in its entirety.
Entailed by these research gaps, the research questions formulated in this chapter are considered to be lacking in the field.

As such, the study performed for the purposes of this dissertation is relevant to the field of computer science by expanding upon the the knowledge of graphics acceleration in virtual platforms; in terms of facilitating debugging, testing, and profiling of software dependent on \dvttermgpu\ graphics acceleration.

By the means outlined in chapter \ref{cha:aimsandobjectives}, this dissertation contributes to the field of computer science by answering these questions from the perspective of graphics paravirtualization in the \dvttermsimics\ full-system simulator.
Accordingly, the key investigatory attributes and explicit research question formulations, sought after to answer by this thesis, are presented below.

\newcommand*\researchquestionitem[2]{\item[#1:] \textit{#2}}
\begin{multicols}{2}
\begin{itemize*}
	\researchquestionitem{1}{What are the benefits and disadvantages of paravirtualized graphics in virtual platforms?}
	\researchquestionitem{2}{What are the prerequisites of \dvttermdeterministicexecution\ of paravirtualized graphics in virtual platforms?}
	\researchquestionitem{3}{What are the prerequisites of \dvttermcheckpointing\ of paravirtualized graphics in virtual platforms?}
	\researchquestionitem{4}{What are the prerequisites of \dvttermreverseexecution\ of paravirtualized graphics in virtual platforms?}
\end{itemize*}
\end{multicols}

\noindent
Pursuant to the aim and objectives specified in chapter \ref{cha:aimsandobjectives}, this thesis pertain to the concepts described in this chapter.

% Graphics Virtualization
\section{Graphics Virtualization}
\label{sec:background_graphicsvirtualization}
As expanded upon in \dvtcmdcitefur{dissertation:nilsson:2014}, there are a number of ways of virtualizing \dvttermgpu s in system simulators, a few of which accomodate for hardware acceleration of \dvttermgpu\ kernels.
When faced with tackling the issue of \dvttermgpu\ virtualization, there are equally many variables to consider as there are options; the first of which is the purpose of said virtualization.
The \dvttermsimics\ architectural simulator is by all means a full-system simulator; meaning, as portrayed in section \ref{sec:background_simics}, that it may run real-software stacks without modification.
However, \dvttermsimics\ is intended to feature a low level of timing fidelity for the purposes of high performance, and is - as such - not a cycle-accurate simulator.
In this way, and in line with the considerations for \dvttermgpu\ virtualization, one must analyze and balance the purposes of simulation since there is not always a general winning-case.
As such, methodologies with varying levels of implementational accuracy present themselves - from slow low-level instruction set modeling to fast high level paravirtualization of an assortment of graphics frameworks.
Said methods are presented in paragraphs \dvtcmdrefname{par:background_graphicsvirtualization_gpumodeling}, \dvtcmdrefname{par:background_graphicsvirtualization_pcipassthrough}, \dvtcmdrefname{par:background_graphicsvirtualization_softmodeling}, and \dvtcmdrefname{par:background_graphicsvirtualization_paravirtualization}.

% TODO: Insert figure visualizing virtualization methodologies (see https://github.com/CaterHatterPillar/dv2524/issues/161).
\missingfigure[figwidth=6cm]{Visualization of GPU virtualization methodologies.}

% GPU Modeling
\paragraph{GPU Modeling}
\label{par:background_graphicsvirtualization_gpumodeling}
Firstly, one may consider developing a full-fletched \dvttermgpu\ model; that is, virtualizing the \dvttermgpu\ \dvttermisa .
This methodology may be appropriate for the purposes of low-level development close to \dvttermgpu\ hardware.
For example, one might imagine the scenario of driver development for next-generation \dvttermgpu s, as portrayed in the thesis proposal (see \dvtcmdcitefur{dissertation:nilsson:2014}).

However, the development of \dvttermgpu\ models, similar to that of common architectural model development for the \dvttermsimics\ full-system simulator, incurs a number of flaws.
The first of these flaws, due to \dvttermgpu\ hardware - still - often being poorly documented\dvtcmdcitebib{inproceedings:lagarcavilla:2007}, on the contrary to \dvttermcpu\ architectures, driving estimated development costs to unsustainable levels.
Furthermore, such modeling of massively parallelized \dvttermgpu\ technology on \dvttermcpu s induce high costs rendering the methodology less preferable for development requiring high application speed.

% PCI Passthrough
\paragraph{PCI Passthrough}
\label{par:background_graphicsvirtualization_pcipassthrough}
Secondly, one ought examine the benefits of \dvttermpcipassthrough ; allowing virtual systems first-hand - exclusive - access to \dvttermhost\ machine devices\dvtcmdciteref{web:jones:2009}.
The direct contact with \dvttermhost\ system devices accomodated by methodologies such as \dvttermpcipassthrough\ enable performance, hardware accelerated, graphics acceleration.

Yet, the methodology suffers from several disadvantages, such as only being capable of running - as of yet - on \dvttermlinux\ systems\todo{citation needed!}.
Additionally, the solution requires dedicated hardware, causing the \dvttermhost\ system to lose all access to said devices during the course of simulation.
In terms of \dvttermgpu\ virtualization, this would induce the necessity of the \dvttermhost\ machine featuring multiple graphics cards.
The tight coupling induced by direct contact with \dvttermhost\ hardware also requires the simulation \dvttermtarget\ to utilize the same device drivers as the \dvttermhost\ system, rendering the methodology unflexible in terms of \dvttermgpu\ virtualization diversity.
In line with a paravirtualized approach, \dvttermpcipassthrough\ also requires modification of the \dvttermtarget\ system - in addition to configuration of the simulation \dvttermhost .

% Another flaw: Linux only (or rather, not Windows).

% Soft Modeling
\paragraph{Soft Modeling}
\label{par:background_graphicsvirtualization_softmodeling}
Thirdly, as an alternative to precise modeling of \dvttermgpu\ technologies, one might analyze the feasability of high-speed software rasterization.
Albeit not up to hardware accelerated speeds, some results indicate an increased feasibility of high-speed software rasterization in modern graphics frameworks (see \dvtcmdcitefur{papers:nilsson:2013}), where traditional software rasterization is accelerated using thread pooling optimizations and \dvttermsimd\ technologies\dvtcmdciteref{web:microsoft:2013:warp}; all for the purposes of optimizing execution for \dvttermcpu -, rather than \dvttermgpu , execution.
As such, one may avoid some of the overhead induced by simulating \dvttermgpu\ workload on \dvttermcpu s, which is traditionally not fit for purpose.
One might speculate that using such technologies in collaboration with \dvttermhost\ native execution accceleration might bring software rasterization up to competitative speeds fit for some simulatory development purposes, replacing the need for more sophisticated virtualization techniques.

% Paravirtualization
\paragraph{Paravirtualization}
\label{par:background_graphicsvirtualization_paravirtualization}
Finally, and as portrayed throughout this document, there is the option of virtualization by paravirtualization (see chapter \ref{cha:methodologysolution}).
Paravirtualization incurs the benefits of \dvttermhost\ hardware acceleration of some framework graphics library, and is implemented at a relatively high abstraction level\todo{Refer to virtualization layer abstraction visualization figure when existant.}.
Inherent from it's higher abstraction, paravirtualization may be relatively cost-effective to implement - in comparison to alternatives such as \dvtcmdrefname{par:background_graphicsvirtualization_gpumodeling}.
Additionally, virtualizing at the graphics library software level circumvents the need for users to relink or modify the application they wish paravirtualized.
Furthermore, the serialization of framework invocations by the means of fast communications channels (see section \ref{sec:methodologysolution_simicspipe}) may accomodate for significant performance improvements when compared to that of networking solutions (see \dvtcmdcitefur{dissertation:nilsson:2014}).

However, despite the possibility for significant performance improvements (see chapter \ref{cha:results}), graphics virtualization by the means of paravirtualization is not without it's inherent flaws.
In particular, a paravirtualized graphics library may be expensive to maintain as frameworks evolve and specifications change.
Additionally, the means of paravirtualization requires the target system to be modified; albeit not necessarily being a substantial flaw as such a paravirtualized framework may still accelerate unmodifient \dvttermtarget\ applications utilizing said library.
In this way, paravirtualization may be considered to be a decent leveling of the benefits and drawbacks of the various virtualization methodologies presented in this section.

% TODO:
% Expand upon why paravirtualization is a sensible levelling.

% Simics
\section{Simics}
\label{sec:background_simics}
\index{Simics}
% Describe the background of simics
Simics is a \glslink{dvtglossfullsystemsimulation}{full-system simulator} developed by \dvttermintel\ and sold through \dvttermintel s subsidiary \dvttermwindriver\
Simics was originally developed by the simulation group at the \dvttermsics\ (this being the first instance of an academic group running an unmodified \dvttermos\ in an entirely simulated environment) including \dvttermgoogle s Peter S. Magnusson; the members of which founded \dvttermvirtutech \footnote{Virtutech was aquired by \dvttermintel\ in \dvtcmdnum{2010}\dvtcmdciteref{web:miller:2010}.} and commercially launched the product in \dvtcmdnum{1998}\dvtcmdcitebib{journals:magnusson:2013}.\\

\noindent
As an architectural simulator, \dvttermsimics\ primary client group is software- and systems developers that produce an assortment of software for complex systems involving software and hardware interaction\dvtcmdcitebib{journals:aarno:2013}.
As such, key attributes of \dvttermsimics\ are scalability, repeatability, and high-performance simulation.
For these purposes, the simulator supports \dvttermhostvirtualizationextensions , and other performance boosting technologies such as \dvttermhypersimulation \dvtcmdcitebib[p.~38]{publications:leupers:2010}.

Simics also features a number of advanced functionalities, adhering to the deterministic nature of the simulator, such as \dvttermcheckpointing\ (see section \dvtcmdrefname{sec:background_checkpointing}) and \dvttermreverseexecution\ (see section \dvtcmdrefname{sec:background_reverseexecution})\dvtcmdcitebib{publications:leupers:2010}.\\

\noindent
The ability to simulate the entirety of an unmodified software stack has led to Simics being used to simulate a variety of systems including, but not limited to, single-processor embedded boards, multiprocessor servers, and heterogeneous telecom clusters\dvtcmdcitebib{journals:aarno:2013}.

Current employers of the \dvttermsimics\ full-system simulator include, but are not limited to, \dvttermibm \dvtcmdcitebib[p.~12:1,~12:6]{journals:koerner:2009}, \dvttermnasa \dvtcmdciteref{web:windriver:2014}\dvtcmdciteref{web:nasa:2014}, and \dvttermintel \dvtcmdcitebib[p.~100]{journals:veselyi:2013}.
Other past and current employers of the simulator include \dvttermsunmicrosystems , \dvttermericsson , and \dvttermhewlettpackard \dvtcmdcitebib{journals:magnusson:2013}, in addition to \dvttermcisco , \dvttermfreescalesemiconductor , \dvttermgeavionics , \dvttermhoneywell , \dvttermlockheedmartin , \dvttermnortel\ and \dvttermnorthropgrumman\ \dvtcmdciteref{web:miller:2010}.

Additionally, the simulator has a strong academic tradition; being known to operate in over \dvtcmdnum{300} universities throughout the world\dvtcmdcitebib[p.~252]{journals:villa:2005}.

% TODO:
% Explain the concepts of simulation target- and host.

% Deterministic Execution
\section{Deterministic Execution}
\label{sec:background_deterministicexecution}
\index{Deterministic Execution}

\glslink{dvtglossdeterministicexecution}{'Deterministic execution'} commonly refers to the execution of \dvttermdeterministicalgorithm s; meaning that a certain function, given a definite input, will produce a decisive output - throughout the process in which the system passes through a distinct set of states (see \dvtcmdcitebib{journals:cohen:1979} for an overview on \glslink{dvtglossdeterministicalgorithm}{deterministic- and non-deterministic algorithms}).
Some sources have voiced concerns over the consequences, in terms of debugging, of non-deterministic behaviour caused by concurrent software\dvtcmdcitebib[p.~3-5]{journals:lee:2006}\dvtcmdcitebib[p.~92]{journals:holzmann:1997}.
Some even go as far as to argue that determinism is a prerequisite for effective debugging and testing\dvtcmdcitebib[p.~3,~4]{dissertation:devietti:2012}\dvtcmdcitebib[p.~51,~59]{inproceedings:yu:2012}.
As such, deterministic behaviour may be seen as a valuable attribute in a virtual platform (see \dvtcmdcitebib[p.~1,~2]{papers:bergan:2011} for an overview on the value of determinism in software development).

In \dvttermsimics , '\dvttermdeterministicexecution ' denotes the entire \dvttermtarget\ system as a \dvttermdeterministicalgorithm , wherein all instructions are executed in a deterministic manner on the simulated hardware\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013}.
This means that the simulated system (e.g., an \dvttermos ), presuming the same input, will allocate the same memory space in virtual memories, receive the same number of interrupts in sequence, and even inhabit the same registers in virtual \dvttermcpu s\dvtcmdcitebib[p.~19,~20]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2012:determinism} for a brief rundown of \dvttermdeterministicexecution\ in \dvttermsimics ).
As such, given an arbitrary number of instructions, the simulation state may be recreated indiscriminately down to the level of the instruction set and corresponding cycles.

Thus, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermdeterministicexecution\ refers to the deterministic state transition of a \dvttermtarget\ system; as described in this paragraph.

% Checkpointing
\section{Checkpointing}
\label{sec:background_checkpointing}
\index{Checkpointing}

The state of a computer system may be defined as the entirety of its stored information, or memory, at a given time\dvtcmdcitebib[p.~103]{publications:harris:2007}.
It may be benificial to store such states in a '\dvttermcheckpointrestart ' scheme, as suggested by Jiang et al. in regards to \dvttermcuda\ kernels\dvtcmdcitebib[p.~196-197,~210]{inproceedings:zhang:2013}.
In this way, developers may save- and restore the state of a system which can reduce overhead of restarting computationally heavy applications from scratch\dvtcmdcitebib[p.~19,~20]{journals:aarno:2013}.

In \dvttermsimics , '\dvttermcheckpointing ' refers to the functionality to save the complete state of a simulation into a portable format.
When applied, this format is known as a \dvttermcheckpoint .
This ability not only  saves time in terms of program initialization and debugging\dvtcmdcitebib[p.~54]{journals:magnusson:2002}, but may also ease testing and collaboration in-between developers as \dvttermcheckpoint s may be distributed and shared\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2013:collaboratingusingsimics} for an overview on \dvttermcheckpointing\ in \dvttermsimics ).

As such, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermcheckpointing\ denotes said functionality.

% Reverse Execution
\section{Reverse Execution}
\label{sec:background_reverseexecution}
\index{Reverse Execution}

\glslink{dvtglossreverseexecution}{'Reverse execution'} provides software developers with the ability to return, often from portable \dvttermcheckpoint s, to previous states of execution\dvtcmdcitebib[p.~2,~3]{journals:akgul:2004}.
This may be useful when debugging, profiling, or testing as difficult-to-reach system states may be stored and returned to, effectively bypassing program initialization and other hindrances\dvtcmdcitebib[p.~54]{journals:magnusson:2002}.

In \dvttermsimics , '\dvttermreverseexecution ' denotes said ability - covering the entirety of the simulated system\dvtcmdcitebib[p.~30,~31]{publications:leupers:2010}.
As such, simulated systems may be run in reverse; including virtualized hardware device states, disk contents and \dvttermcpu\ registers\dvtcmdcitebib[p.~20,~21]{journals:aarno:2013} (see \dvtcmdciteref{web:engblom:2013:backtorevexe} for an overview on \dvttermreverseexecution\ in \dvttermsimics ); whilst still maintaining determinism in the simulated system.

As such, throughout this document and in relation to the \dvttermsimics\ full-system simulator, \dvttermreverseexecution\ refers to the functionality described in this section.

% Magic Instructions
\section{Magic Instructions}
\label{sec:background_magicinstructions}
\index{Magic Instruction}
Sometimes during system simulation, there may be reasons as to why one would like to escape the simulation and resume execution in the real world.
Such a scenario would be a debugging breakpoint, to share data in-between \dvttermtarget\ and \dvttermhost\ systems, or for any reason modify the simulation state.
There are a number of ways to communicate with the outside world (including the \dvttermhost\ machine) from within the simulation, such as by networking means or specially devised kernel drivers, but few are as instant as the - arguably - legitimately coined '\dvttermmagicinstruction '.

The \dvttermmagicinstruction s a concept used to denote a \dvtcmdcodeinline{nop}-type instruction, meaning an instruction that would have no effect if run on the \dvttermtarget\ architecture (such as \dvtcmdcodeinline{xchg ebx, ebx}\footnote{'Swap contents in registers \dvtcmdcodeinline{ebx} and \dvtcmdcodeinline{ebx}'.} on the \dvttermxeightysix -architecture), which - when executed on the simulated hardware in a virtual platform - invokes a certain callback-method\dvtcmdcitebib[p.~32]{publications:leupers:2010}.
An advantage of this methodology is an often negligible invocation cost, as the context switch is often instant from the perspective of the \dvttermtarget\ system\dvtcmdcitebib[p.~131]{journals:rechistov:2013}.
Furthermore, and a greatly desireable attribute, \dvttermmagicinstruction s require no modification of the \dvttermtarget\ system.
Another advantage of the \dvttermmagicinstruction\ paradigm is that the system invoking such an instruction may, without complications, run outside of a simulation - as this would simply result in regular \dvtcmdcodeinline{nop}-behaviour.

In effect, implementation of \dvttermmagicinstruction s requires replacing one- or more instructions in the \dvttermtarget\ instruction set; thereby making the \dvttermmagicinstruction\ platform-dependent.
However, the solution is often designed to only respond to \dvttermmagicinstruction s wherein a certain magic number, sometimes called a 'leaf number'\dvtcmdcitebib[p.~131]{journals:rechistov:2013}, is present in an arbitrary processor register.

% Virtual Time
\section{Virtual Time}
\label{sec:background_virtualtime}
\index{Virtual Time}
In terms of system simulation, time often becomes an abstract; since it is not necessarily the same for an observer outside of the simulation as that of an observer from the inside.
The variance in virtual time, as compared to that of real-world time, is called 'simulation slowdown' and may reach orders of magnitudes faster than that of real-world time, or likewise order of magnitude slower.

The concepts of real- and virtual time are particularily important when considering performance measurements.
When attempting to establish some sort of measurement in a full-system simulator, such as \dvttermsimics , one must contemplate what type of time is relevant to the study being performed.
For graphics acceleration of real-time applications, it is likely that the real-world wall clock is the primary point of reference (see section \ref{sec:methodologyexperiment_platformprofiling} for an elaboration on how time measurement is performed for the sake of this study).
However, there are cases in which virtual time is more relevant to analyze.

%Explain the concepts of virtual time. Expand upon how timing was achieved in Simics and QEMU, respectively.
%http://stackoverflow.com/questions/5774612/is-the-emulator-clock-synced-to-the-real-system-clock
%https://wiki.diebin.at/Under_the_hood_of_Android_Emulator_(appcert)#vl-android.c.2Finit_clocks.28.29:
%http://gamasutra.com/view/feature/171774/getting_high_precision_timing_on_.php?print=1