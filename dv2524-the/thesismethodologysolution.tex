% thesismethodologysolution.tex
% Chapter Methodology, Solution.

% Methodology, Solution:
\chapter{Methodology, Solution}
\label{cha:methodologysolution}
The implementation constitutes the realization of the paravirtualized technology described in this document and corresponding thesis proposal (see \dvtcmdcitefur{dissertation:nilsson:2014}).
Throughout this document, several concepts and phrases may be recognized and related to the Android Hardware OpenGL ES emulation design overview (see section \dvtcmdrefname{sec:appendixa_referencesolution} under \dvtcmdrefname{cha:appendixa}).\\

\noindent
In accordance to the \dvttermreferenceimplementation , paravirtualized graphics acceleration is achieved by the means of three overall components; being the Target System Libraries, the Host System Libraries, and the communications channel aptly named the Simics Pipe (see \dvtcmdcitefur{dissertation:nilsson:2014} for an elaboration on the purposes of said components).

% Expand on general methodology in terms of system simulation, and describe simulation layer target using descriptive figure.

%Cite dv2549:
%Something akin to: "...although there are findings indicating that CPU simulation of GPUs is getting increasingly feasible..."

\ldots

\missingfigure[figwidth=6cm]{Visualization of solution components.} % TODO: Insert figure visualizing structure of solution

\section{OpenGL ABI Generation}
\label{sec:methodologysolution_openglabigeneration}
\index{OpenGL ABI Generation}
In order to save in on precious development time, and ensure the scalability of the solution during development of the benchmarks that were developed for the purposes of this dissertation (see section \ref{sec:methodologyexperiment_benchmarking}), a set of scripts automating the generation of library source code is used to generate the majority of the target- and host system libraries (see section \ref{sec:methodologysolution_targetsystemlibraries} \& \ref{sec:methodologysolution_hostsystemlibraries}).
As such, the majority of the \dvttermopengl\ function definitions described in section \ref{sec:methodologysolution_targetsystemlibraries} are produced by this tool.
The functionality is implemented in a set of \dvttermpython\ scripts that, from a number of specification files detailing function signatures and argument attributes, generate both headers and source files in \dvttermc .

% TODO:
% Expand on the extent of methods being generated, including inout vairables, return values etc.
% Point out what kind of methods are not being generated.

\section{Target System Libraries}
\label{sec:methodologysolution_targetsystemlibraries}
\index{Target System Libraries}
The target system libraries are comprised of implementations of the \dvttermegl - and \dvttermopengl\ \dvttermapi s.
Due to the tight coupling in-between \dvttermopengl\ and the platform windowing system, the solution must also accelerate the \dvttermkhronos\ \dvttermegl\ \dvttermapi , that is the interface between \dvttermopengl\ and the underlying platform windowing system (see \ref{sec:methodologysolution_windowingsystems} for an elaboration on the full extent of \dvttermegl\ interaction).
As may be derived from the name, the target system libraries run on the simulation \dvttermtarget\ system.

As such, the target systems libraries implement the \dvttermegl - and \dvttermopenglestwopointo\ \dvttermapi s and lures whatever application it is being linked to that it is, in fact, the expected platform libraries.
However, instead of communicating with the platform windowing system (in terms of \dvttermegl ) and the graphics device (in terms of \dvttermopengl ) - and instructing said device in coagency with the user; the target system libraries rather serialize the given command stream and forwards it to the simulation \dvttermhost .
However, the transmission of the command stream is not necessarily performed at once, or in the designated order due to the formation of the \dvttermopenglestwopointo\ framework.
This complex of problems involve uncertanties of the proportion of argument data, as size is not necessarily specified by the user.
As such, certain method serialization may have to be delayed until further information surrounding the argument	dimensions have been relayed to the \dvttermopengl\ library.

The serialization described in the above paragraph is thus formatted and encoded in accordance to a certain data format, which is kept as minimal as possible throughout execution.
This encoding includes packing variable length data types, such as 8-bit characters, 16-bit fields, or 64-bit integer values into fixed length structures, so that the \dvttermhost\ system may interpret these values independently of how corresponding types are defined on that unrelated platform\footnote{It should be noted, however, that the solution assumes a little endian architecture and floating point 754 standard for floating point representation. If the \dvttermhost\ system would not conform to these prerequisites, the solution would have to be complemented with additional support.}.

Furthermore, a subset of the \dvttermopengl\ state need be maintained by the target system libraries.
These attributes are comprised by, inter alia, bound vertex- and index element buffers, in addition to properties of \dvttermopengl\ vertex attributes.
Such states must be kept in the target system libraries due to the asynchronous nature of \dvttermopengl\ invocation serialization described in the above paragraph.\\

\noindent
Given that the target system libraries adheres to the \dvttermopengl\ headers defined in the system, the application is na\"{\i}ve in terms of it's paravirtualized status.
The interplay with the original \dvttermopengles\ headers also results in the solution adhering to the platform-dependant type definition, flags, and constants; as originally defined by \dvttermkhronos .

The target system libraries are written in \dvttermc\ and \dvttermcplusplus .
See \dvtcmdcitefur{dissertation:nilsson:2014} for more information on the methodology behind the target system libraries.

\section{Host System Libraries}
\label{sec:methodologysolution_hostsystemlibraries}
\index{Host System Libraries}
In collaboration with the target system libraries (see \ref{sec:methodologysolution_targetsystemlibraries}), the host system libraries - running on the \dvttermhost\ system - subsequently decodes and interprets the recieved byte stream.
Said decoding involves unpacking data from fixed length storage into variable-size types that the \dvttermopengl\ libraries expect.
Furthermore, and again similarly to the target system libraries, due to some design decitions inherent in the \dvttermopenglestwopointo\ framework, the host system libraries need maintain some data; in particular - vertex attributes.
Such data is buffered in the host system libraries until drawn in a later, and seperate, \dvttermopengl\ invocation\footnote{A possible optimization would be to cache said data, to avoid the need to transmit unmodified vertices multiple times, despite so being specified by the user.}.
When the requested \dvttermopengl\ invocation has been performed, any return- or in-out values are returned to the \dvttermtarget\ system using the Simics Pipe (see \ref{sec:methodologysolution_simicspipe}).

As with the the target system libraries, the recieving end of an \dvttermopengl\ method definition in the host system libraries are likewize generated to a large degree (see \ref{sec:methodologysolution_openglabigeneration}).

The host system libraries are written in \dvttermc\ and \dvttermcplusplus .
See \dvtcmdcitefur{dissertation:nilsson:2014} for more information on the methodology behind the host system libraries.

\section{Windowing Systems}
\label{sec:methodologysolution_windowingsystems}
Due to variations in the creation and maintinence of windows on different platforms (e.g., \dvttermfedora\ \& \dvttermandroid ), incurred by said platforms utilizing different interfaces for the purpose, this was considered out-of-scope for this study.
As such, for the purposes of this dissertation, the window to which \dvttermopengl\ renders is kept on the simulation \dvttermhost , in accordance to the scope outlined in the thesis proposal (see \dvtcmdcitefur{dissertation:nilsson:2014}).

The problem may be summarized as the dilemma of the target system libraries having to communicate with the correct window (located in the simulation \dvttermhost ), yet having the \dvttermtarget\ system window reporting sucessful initialization.
After all, it would be problematic if the \dvttermopengl\ utilizing application would have to be modified in order to be paravirtualized.
Effectively, this means that it would be desireble to maintain the native functionality of the target system \dvttermegl\ library.
However, in order to swap the backbuffers to which \dvttermopengl\ renders in the window present in the \dvttermhost\ system, one must use \dvttermegl\ methods.
In this way, the problem comprises a conflict in-between wanting to keep the functionality of the native \dvttermegl\ library, yet modify a small subset. 
This issue is overcome by the use of symbol overriding\footnote{Utilizing \dvtcmdcodeinline{LD_PRELOAD} on the \dvttermlinux\ platform.}, which allows the target system libraries to overload a function, serialize and forward the invocation to the \dvttermhost\ system as described in \ref{sec:methodologysolution_targetsystemlibraries}, locate the next occurance of the same symbol in the symbol table (being the original native \dvttermegl\ function definition), and invoke the original function.
As such, the target system \dvttermegl\ library does not replace the native \dvttermtarget\ \dvttermegl\ library, as with the target system \dvttermopengl\ library, but rather overloads some of it's definition.
This gives the effect of a sucessfully created window, not having returned any errors in the window creation and maintinence - yet having the application actually communicating with an entirely different window present only in the \dvttermhost\ system.
As such, the target system libraries is effectively performing a man-in-the-middle attack.

At the time of writing, the target system libraries simply overload the \dvtcmdcodeinline{eglSwapBuffers} function, but the methodology could easily be extended to listen in on requested window dimensions and other window attributes - effectively circumventing the need to heed any differences in-between platform windowing systems.

\section{Simics Pipe}
\label{sec:methodologysolution_simicspipe}
\index{Simics Pipe}
% Extended GCC Assembly
% Linux locked memory
% Page traversal w. visualization
% C


\missingfigure[figwidth=6cm]{Figure visualizing memory page traversal during translation.} % TODO: Insert figure visualizing structure memory page traversal when sharing memory in-between target and host systems.

%See \dvtcmdcitefur{dissertation:nilsson:2014} for more information on the methodology behind the Simics Pipe.

%Considering magic instructions having been used for the purposes of hardware acceleration previously \dvtcitebib[p.~32]{publications:leupers:2010}...


