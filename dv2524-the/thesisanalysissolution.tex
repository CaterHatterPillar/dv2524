% thesisanalysissolution.tex
% Chapter Analysis, Solution

% TODO:
% Consider moving to Methodology, Solution chapter?

% Analysis, Solution
\chapter{Analysis, Solution}
\label{cha:analysissolution}
As expanded upon in \dvtcmdcitefur{dissertation:nilsson:2014}, there are a number of ways of virtualizing \dvttermgpu s in system simulators, a few of which accomodate for hardware acceleration of \dvttermgpu\ kernels.
When faced with tackling the issue of \dvttermgpu\ virtualization, there are equally many variables to consider as there are options; the first of which is the purpose of said virtualization.
The \dvttermsimics\ architectural simulator is by all means a full-system simulator; meaning, as portrayed in section \dvtcmdrefname{sec:background_simics} under \dvtcmdrefname{cha:appendixa}, that it may run complete real-software stacks without modification.
However, \dvttermsimics\ is intended to feature a low level of timing fidelity for the purposes of high performance, and is - as such - not a cycle-accurate simulator\footnote{This should not be confused with...}\todo{?}.
As such, and in line with the considerations for \dvttermgpu\ virtualization - one must analyze and balance the purposes of simulation, as there is not always a winning general-case.
In this way, methodologies with varying levels of implementational accuracy present themselves - from slow low-level instruction set modeling to fast high level paravirtualization.
Said methods are presented in the paragraphs below, and visualized in figure...\todo{Refer to figure}

% GPU Modeling
\paragraph{GPU Modeling}
\label{par:analysissolution_gpumodeling}
Firstly, one may consider developing a full-fletched \dvttermgpu\ model; that is, implementing virtualization of the \dvttermgpu\ \dvttermisa .
This methodology may be appropriate for the purposes of low-level development close to \dvttermgpu\ hardware.
For example, one might imagine the scenario of driver development for next-generation \dvttermgpu s, as portrayed in the thesis proposal (see \dvtcmdcitefur{dissertation:nilsson:2014}).

However, the development of \dvttermgpu\ models, similar to that of common architectural model development for the \dvttermsimics\ full-system simulator, incurs a number of flaws.
The first of these flaws, due to \dvttermgpu\ hardware - still - often being poorly documented\dvtcmdcitebib{inproceedings:lagarcavilla:2007}, on the contrary to \dvttermcpu\ architectures, driving estimated development costs to unsustainable levels.
Furthermore, such modeling of massively parallelized \dvttermgpu\ technology on \dvttermcpu s induce high costs rendering the methodology less preferable for development requiring some application speed.

% PCI Passthrough
\paragraph{PCI Passthrough}
\label{par:analysissolution_pcipassthrough}
Secondly, one ought examine the benefits of \dvttermpcipassthrough ; allowing virtual systems first-hand - exclusive - access to \dvttermhost\ machine devices\dvtcmdciteref{web:jones:2009}.
The direct contact with \dvttermhost\ system devices accomodated by methodologies such as \dvttermpcipassthrough\ enable performance, hardware accelerated, graphics acceleration.

Yet, the methodology suffers from several disadvantages, such as only being capable of running on \dvttermlinux\ systems \todo{citation needed!}.
Additionally, the solution requires dedicated hardware, followed by the \dvttermhost\ system losing all access to said devices during the course of simulation.
In terms of \dvttermgpu\ virtualization, this would induce the necessity of the \dvttermhost\ machine featuring multiple graphics cards.
The tight coupling induced by direct contact with \dvttermhost\ hardware also requires the simulation \dvttermtarget\ to utilize the same device drivers as the \dvttermhost\ system, rendering the methodology unflexible in term so \dvttermgpu\ virtualization diversity.
In line with a paravirtualized approach, \dvttermpcipassthrough\ also requires modification of the \dvttermtarget\ system - in addition to configuration of the simulation \dvttermhost .

% Another flaw: Linux only (or rather, not Windows).

% Soft Modeling
\paragraph{Soft Modeling}
\label{par:analysissolution_softmodeling}
Thirdly, as an alternative to precise modeling of \dvttermgpu\ technologies, one might analyze the feasability of high-speed software rasterization.
Albeit not up to hardware accelerated speeds, some results indicate an increased feasibility of high-speed software rasterization in modern graphics frameworks (see \dvtcmdcitefur{papers:nilsson:2013}), where traditional software rasterization is accelerated using thread pooling optimizations and \dvttermsimd\ technologies\dvtcmdciteref{web:microsoft:2013:warp}; all for the purposes of optimizing execution for \dvttermcpu -, rather than \dvttermgpu , execution.
As such, one may avoid some of the overhead induced by simulating \dvttermgpu\ kernels on the \dvttermcpu , which is traditionally not fit for purpose.
One might speculate that using such technologies in collaboration with \dvttermhost\ native execution accceleration might bring software rasterization up to competitative speeds fit for some simulatory development purposes, replacing the need for more sophisticated virtualization techniques.

% Paravirtualization
\paragraph{Paravirtualization}
\label{par:analysissolution_paravirtualization}
Finally, and as portrayed throughout this document, there is the option of virtualization by paravirtualization (see chapter \ref{cha:methodologysolution}).
Paravirtualization incurs the benefits of \dvttermhost\ hardware acceleration of some framework graphics library, and is implemented at a relatively high abstraction level\todo{Refer to virtualization layer abstraction visualization figure when existant.}.
Inherent from it's higher abstraction, paravirtualization may be relatively cost-effective to implement - in comparison to alternatives such as \dvtcmdrefname{par:analysissolution_gpumodeling}.
Additionally, virtualizing at the graphics library software level circumvents the need for user to relink or modify the application they wish paravirtualized.
Furthermore, the serialization of framework invocations by the means of fast communications channels (see section \ref{sec:methodologysolution_simicspipe}) may accomodate for significant performance improvements.

However, despite possibility for significant performance improvements (see chapters \ref{cha:analysisexperiment} \& \ref{cha:results}), graphics virtualization by the means of paravirtualization is not without it's inherent flaws.
In particular, a paravirtualized graphics library may be expensive to maintain as frameworks evolve and specifications change.
Additionally, the means of paravirtualization requires the target system to be modified; albeit not necessarily being a substantial flaw as such a paravirtualized framework may still accelerate unmodifient \dvttermtarget\ applications utilizing said library (see...\todo{refer to figure}).

% TODO:
% Expand upon why paravirtualization is a sensible levelling.

% TODO: Insert figure visualizing virtualization methodologies (see https://github.com/CaterHatterPillar/dv2524/issues/161).
\missingfigure[figwidth=6cm]{Visualization of GPU virtualization methodologies.}

% Deterministic Execution (section Determinism in OpenGL ES)
\section{Deterministic Execution}
\label{sec:analysissolution_deterministicexecution}
\ldots

% Checkpointing
\section{Checkpointing}
\label{sec:analysissolution_checkpointing}
\ldots

% Reverse execution
\section{Reverse Execution}
\label{sec:analysissolution_reverseexecution}
\ldots
